# Введение
Выжимки в стандарт из книга Владимира Хорикова "Принципы юнит-тестирования"

Важно стремиться к тому, чтобы свести к минимуму
усилия, потраченные на написание тестов, и максимизировать преимущества, которые они приносят.
Совместить эти две задачи не так просто.

> Необходимость писать юнит-тесты обычно приводит к улучшению качества кода. Но
это не главная цель юнит-тестирования, а всего лишь приятный побочный эффект.


> Тесты помогают справиться с деградацией кодовой базы. 
> Они становятся своего рода «подушкой безопасности» — средством, которое обеспечивает защиту против большинства регрессий. 
> Тесты помогают удостовериться в том, что существующая функциональность работает даже после разработки новой функциональности или рефакторинга кода.

Включайте в проект только наиболее эффективные тесты и избавляйтесь от всех остальных. 
И код приложения, и код тестов — обязательство, а не актив (liabilities, not assets).

При этом тесты это не то, что делается "на сдачу" - это такой же важный код, который нужно писать читамо и поддерживаемо, т. к. тесты
будут развиваться как часть кодовой базы.

# Стандарт для тестов
- пишем тесты в стиле классической школы по паттерну AAA.
- одно утверждение в тесте.
- тестируем поведение системы.
- минимизируем использование mock'ов;
- используем "мягкие утверждения"; 
- использовать AssertJ для утверждений.

# Постоянный Рефакторинг
Постоянный рефакторинг кодовой базы, улучшение модели, тестов - это лучшая практика, которую инженер применяет каждый день.
Нужно принять тот факт, что мы постоянно находимся в процессе рефакторинга и привнесения улучшений. Тесты помогают нам в этом.

## Затраты на юнит-тесты
- рефакторинг теста при рефакторинге кода;
- выполнение теста при каждом изменении кода;
- отвлечение на ложные срабатывания теста;
- затраты на чтение теста при попытке понять, как работает код.

# Цель юнит-тестирования
Обеспечение стабильного роста программного проекта.

# Что такое юнит-тест?
Юнит-тестом называется автоматизированный тест, который:
- проверяет правильность работы небольшого фрагмента кода (также называемого юнитом);
- делает это быстро
- и поддерживая изоляцию от другого кода.

# Что принимаем за юнит?
Классическая школа, как путь к эффективным тестам.

Вопрос изоляции — это корень различий между классической и лондонской школой
юнит-тестирования.

Лондонская школа описывает это как изоляцию тестируемого кода от его зависимостей. 
Это означает, что если класс имеет зависимость от другого класса или нескольких классов, все такие зависимости должны быть заменены на тестовые заглушки (test doubles).
Лондонский стиль рассматривает вопрос изоляции как отделение тестируемого кода от его коллабораторов с помощью моков.

В классическом подходе изолируются друг от друга не фрагменты рабочего кода, а сами тесты. 
Такая изоляция позволяет вам запускать эти тесты параллельно, последовательно и в любом порядке, не влияя на результат работы этих тестов.

Классический подход к изоляции не запрещает вам тестировать несколько классов одновременно, 
при условии что все они находятся в памяти и не обращаются к совместному состоянию (shared state), 
через которое тесты могут влиять на результат выполнения друг друга. 
Типичными примерами такого совместного состояния служат внепроцессные (out-of-process) зависимости — база данных, 
файловая система и т. д.
![Классическая школа](visual/unit-test-classic.png)

Юнит не обязан ограничиваться классом. 
Вы можете юнит-тестировать как один класс, так и несколько классов, при условии, 
что ни один из них не является совместной зависимостью.

## Определения

### SUT
SUT, system under test.
SUT — весь класс.

### MUT
MUT, method under test.
MUT - метод.

- тестовая заглушка (test double) — общий термин, описывающий любые разновидности фиктивных зависимостей, используемых в тестах;
- мок (mock) — всего лишь одна из разновидностей таких зависимостей.

# Эффективные юнит-тесты
Успешный набор тестов обладает следующими свойствами:
- он интегрирован в цикл разработки;
- он проверяет только самые важные части вашего кода;
- он дает максимальную защиту от багов с минимальными затратами на сопровождение.

Самой важной является часть, содержащая бизнес-логику, — модель предметной области (доменная модель). 
Тестирование бизнес-логики обеспечивает тестам наилучшую эффективность.
Все остальные части можно разделить на три категории:
- инфраструктурный код;
- внешние сервисы и зависимости — например, базы данных и сторонние системы;
- код, связывающий все компоненты воедино.

## Тестируем поведение
Тесты написаны в классическом стиле и используют стандартную последовательность из трех фаз:
- Arrange/Act/Assert — сокращенно AAA
- 
Работаем по классике - стремимся не использовать МОК-и

# Метрики покрытия
Метрики покрытия не могут стать основой для определения качества тестов в вашем проекте.
Лучше всего рассматривать метрику покрытия как индикатор, а не как самоцель.
Метрики покрытия служат хорошим негативным, но плохим позитивным признаком. 
Низкий процент покрытия — хороший признак проблем с тестами, но высокий процент покрытия еще не означает высокого
качества тестов.

Установление конкретного процента покрытия как цели создает неправильный
стимул. Обеспечивать высокий процент покрытия для основных частей вашей
системы хорошо, но не следует превращать этот высокий процент в требование.

# Интеграционные тесты


# Рекомендации